# Использование замыканий в Express при написании Middleware.

## Предисловие

- Автор: Connor Turland(@Connoropolous).
- Оригинал: http://blog.bithound.io/using-closure-to-write-express-middleware/.

Перевод вольный, а это значит что автор перевода вносит небольшие корректировки в текст материала для более удобного восприятия читателем.

Термины:
- middleware - промежуточный обработчик - мидлварь.
- closures - замыкания - кложуры.

## Начало

При написании нового веб приложения средствами node, ужасает мысь того сколько нужно знать. Express прекрасный npm пакет для создания веб сервервов, но всегда остается много вопросов, как лучше всего писать код. Стандартный подход коддинга это использование примеров с оф. сайта Express. Например:

```
app.get('/example/b', function (req, res, next) {
	console.log('response will be sent from the next function...');
	next();
}, function (req, res) {
	res.send('Hello from B!');
});
```


> 1. '/example/b'
>
> 2. function (req, res, next) {
>	console.log('response will be sent from the next function...');
>	next();
>}
>
>2. function (req, res) {
>	res.send('Hello from B!');
>}

В этом примере первый параметр это строка определющая маршрут(1), остальные два параметра это функции(2,3). Таким образом мы можем передать одну или более функций, которые будут работать вместе как middleware.

Сперва это не сразу понятно, но единожды выучив все становится на свои места. Когда клиент обращается по маршруту, функции вызываются последовательно в соотвецтвии той очереди которую мы определили. То есть небольшая особенность. Каждая ф-ция будет автоматически принимать три параметра.

- 'req' объект - содержит данные и ф-ции относящиеся http запросу от клиента
- 'res' объект - представляет http ответ содержащий данные от сервера для клиента
- 'next' объект - колбек который передает очередь следующей ф-ции(пинает следущую ф-цию)

*Учтите: запрос(req) от клиента требует обязательного ответа(res) от сервера, убедитесь так же что ни при каких остоятельствах между вашей мидлварей и финальной функцией не используется никаких ответов(res).*

Если мы хотим написать мидлварь которая авторизирует запрос, нам необходимо модифицировать первую ф-цию:

```
app.get('/example/b', function (req, res, next) {

	if (req.isAuthenticated()) next();
	else res.send(401); // Don't call the next function, just send the response and stop here

}, function (req, res) {
	res.send('Hello from B!');
});
```

Но что если нам необходимо авторизировать несколько маршрутов ?
Мы можем копипастить, а можем посмотреть в сторону замыканий.

## Что такое замыкания?

Если смотреть в Википедии замыкания сперва могут показатся сложной концепцией, но в нашем случае мы собираемся работать с более понятным определением.

Мозила определяет замыкания как функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, запоминает окружение, в котором она была создана.

Что бы реализовать это, мы будем использовать ф-цию которая возвращает ф-цию. Используя такую стратегию мы уменьшим повторение кода и сделаем его более читабельным что в сумме даст нам больше возможностей.

```
function auth() {
	return function (req, res, next) {
		if (req.isAuthenticated()) next();
		else res.send(401);
	};
}

app.get('/example/a', auth(), function (req, res) {
	res.send('Hello from A!');
});
app.get('/example/b', auth(), function (req, res) {
	res.send('Hello from B!');
});
```

Но почему именно так ? Мы ведь можем просто объявить именную ф-цию и передать ее в качестве мидлвари. Вот так например ?

```
function auth(req, res, next) {
	if (req.isAuthenticated()) next();
	else res.send(401);
};

app.get('/example/a', auth(), function (req, res) {
	res.send('Hello from A!');
});
app.get('/example/b', auth(), function (req, res) {
	res.send('Hello from B!');
});
```

Скажем так, замыкания помогут нам если мы захочем усовершенствовать нашу мидлварь. Например нам необходимо авторизировать конкретного юзера по имени 'Francis' средствами нашей мидлвари. Мы можем передать в ф-цию 'auth' некий параметр и провалидировать его на соответствие, на том маршруте где нам это необходимо.

```
function auth(name) {  
	return function (req, res, next) {
		if (req.isAuthenticated() && name && req.user.name === name) next();
		else if (req.isAuthenticated() && !name) next();
		else res.send(401);
	};
}

app.get('/example/a', auth(), function (req, res) {  
	res.send('Hello from A!');
});
app.get('/example/b', auth('Francis'), function (req, res) {  
	res.send('Hello from B!');
});
```

Функция которая возвращается мидлварей 'auth' оказалась весьма полезным замыканием со значением 'name' взятым из параметров нашей мидлвари. Как пишет Моззила: замыкание ссылается на независимую переменную('name').

Есть обратная сторона медали которая состоит в том что мы немного пожертвовали удобством чтения, код переместился из контекста вызова во внешнюю ф-цию, за счет чего мы получили более чистый вид обработкиков маршрута. Конечно если вы увеличите коллличество мидлварей(три и более) на одной строке обработчиков маршрута это повернет удобство чтения вспять и увеличит дублирование кода.


**p.s.**
Надеюсь статья вам понравилась и принесла какую-то пользу.

Мысли и ошибки в issues или личку в соц. сетях.

>Присеединится к нашему чатику в гиттере

>https://gitter.im/dev-garage/main

>Будем рады!
